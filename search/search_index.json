{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"Ktorfit"},{"location":"#introduction","title":"Introduction","text":"<p>Ktorfit is a HTTP client/Kotlin Symbol Processor for Kotlin Multiplatform (Js, Jvm, Android, iOS, Linux) using KSP and Ktor clients inspired by Retrofit</p>"},{"location":"#installation","title":"Installation","text":"<p>Please see Installation</p>"},{"location":"#quick-start","title":"Quick start","text":"<p>Please see Quick start</p>"},{"location":"#requests","title":"Requests","text":"<p>See Requests</p>"},{"location":"#converters","title":"Converters","text":"<p>See documentation Here</p>"},{"location":"#changelog","title":"Changelog","text":"<p>See changelog</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>Some parts of this project are reusing ideas that are originally coming from Retrofit from Square. Thank you for Retrofit!</p> <p>Thanks to JetBrains for Ktor and Kotlin!</p>"},{"location":"#contributions","title":"Contributions","text":"<p>When you find unexpected behaviour please write an issue</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All important changes of this project must be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#unreleased","title":"[Unreleased]","text":""},{"location":"CHANGELOG/#added","title":"Added","text":""},{"location":"CHANGELOG/#changed","title":"Changed","text":""},{"location":"CHANGELOG/#deprecated","title":"Deprecated","text":""},{"location":"CHANGELOG/#removed","title":"Removed","text":""},{"location":"CHANGELOG/#fixed","title":"Fixed","text":""},{"location":"CHANGELOG/#security","title":"Security","text":""},{"location":"CHANGELOG/#143-2023-07-13","title":"1.4.3 - 2023-07-13","text":""},{"location":"CHANGELOG/#added_1","title":"Added","text":""},{"location":"CHANGELOG/#changed_1","title":"Changed","text":""},{"location":"CHANGELOG/#deprecated_1","title":"Deprecated","text":""},{"location":"CHANGELOG/#removed_1","title":"Removed","text":""},{"location":"CHANGELOG/#fixed_1","title":"Fixed","text":""},{"location":"CHANGELOG/#372-crash-with-xiaomi-on-create-ktorfitbuilder-by-princeparadoxes","title":"372 Crash with Xiaomi on create Ktorfit.Builder by @princeparadoxes","text":""},{"location":"CHANGELOG/#security_1","title":"Security","text":""},{"location":"CHANGELOG/#142-2023-06-25","title":"1.4.2 - 2023-06-25","text":""},{"location":"CHANGELOG/#added_2","title":"Added","text":""},{"location":"CHANGELOG/#changed_2","title":"Changed","text":""},{"location":"CHANGELOG/#deprecated_2","title":"Deprecated","text":""},{"location":"CHANGELOG/#removed_2","title":"Removed","text":""},{"location":"CHANGELOG/#fixed_2","title":"Fixed","text":""},{"location":"CHANGELOG/#323-code-generation-issue-for-multipart-formurlencoded-by-ph1ll1pp","title":"323 Code generation issue for @Multipart / @FormUrlEncoded by @Ph1ll1pp","text":""},{"location":"CHANGELOG/#security_2","title":"Security","text":""},{"location":"CHANGELOG/#141-2023-06-03","title":"1.4.1 - 2023-06-03","text":""},{"location":"CHANGELOG/#added_3","title":"Added","text":""},{"location":"CHANGELOG/#changed_3","title":"Changed","text":"<ul> <li>Upgrade dependencies: Ktor 2.3.1</li> </ul>"},{"location":"CHANGELOG/#deprecated_3","title":"Deprecated","text":""},{"location":"CHANGELOG/#removed_3","title":"Removed","text":""},{"location":"CHANGELOG/#fixed_3","title":"Fixed","text":""},{"location":"CHANGELOG/#236-parsing-error-for-listarray","title":"236 Parsing error for list/array","text":""},{"location":"CHANGELOG/#security_3","title":"Security","text":""},{"location":"CHANGELOG/#140-2023-05-27","title":"1.4.0 - 2023-05-27","text":""},{"location":"CHANGELOG/#added_4","title":"Added","text":"<p>e.g.</p> <pre><code>interface ExampleApi{\nsuspend fun getUser(): Response&lt;User&gt;\n}\n\nval user = userKtorfit.create&lt;ExampleApi&gt;().getUser()\n\nif(user.isSuccessful){\nuser.body()\n}else{\nuser.errorBody()\n}\n</code></pre> <ul> <li>Ktorfit is now using converters factories to apply the converters, similar to Retrofit   see more here https://foso.github.io/Ktorfit/converters/converters/</li> <li>TypeData now has a field \u201ctypeInfo\u201d can be used to convert the Ktor HttpResponse body to the wanted type</li> <li>CallConverterFactory for replacement of CallResponseConverter</li> <li> <p>FlowConverterFactory for replacement of FlowResponseConverter</p> </li> <li> <p>Added support for targets: macosArm64, tvosArm64, tvosX64, tvosSimulatorArm64, watchosSimulatorArm64 #315</p> </li> </ul>"},{"location":"CHANGELOG/#85-added-a-response-class-that-can-be-used-as-a-wrapper-around-the-api-response-the-converter-for-it-is-automatically-applied-thx-to-vovahost-datl4g","title":"85 Added a Response class that can be used as a wrapper around the API Response, the converter for it is automatically applied. thx to @vovahost, @DATL4G","text":""},{"location":"CHANGELOG/#changed_4","title":"Changed","text":"<ul> <li>Upgrade dependencies: Kotlin 1.8.21</li> </ul>"},{"location":"CHANGELOG/#deprecated_4","title":"Deprecated","text":"<ul> <li>ResponseConverter, use Converter.ResponseConverter instead</li> <li>SuspendResponseConverter, use Converter.SuspendResponseConverter instead</li> <li>RequestConverter, use Converter.RequestParameterConverter instead</li> <li>See also: https://foso.github.io/Ktorfit/converters/migration/</li> </ul>"},{"location":"CHANGELOG/#removed_4","title":"Removed","text":""},{"location":"CHANGELOG/#fixed_4","title":"Fixed","text":""},{"location":"CHANGELOG/#security_4","title":"Security","text":""},{"location":"CHANGELOG/#130-2023-05-14","title":"1.3.0 - 2023-05-14","text":""},{"location":"CHANGELOG/#added_5","title":"Added","text":""},{"location":"CHANGELOG/#changed_5","title":"Changed","text":"<ul> <li> <p>Optimized generated code, the generated code that is used for a request will   now directly set the Ktor code instead of delegating it to a Ktorfit class. This will  make the code easier to understand.</p> </li> <li> <p>KSP version 1.0.11 is now needed</p> </li> </ul>"},{"location":"CHANGELOG/#deprecated_5","title":"Deprecated","text":""},{"location":"CHANGELOG/#removed_5","title":"Removed","text":""},{"location":"CHANGELOG/#fixed_5","title":"Fixed","text":"<p>[Bug]: IllegalArgumentException with Custom Http Annotation #274</p>"},{"location":"CHANGELOG/#security_5","title":"Security","text":""},{"location":"CHANGELOG/#bumped","title":"Bumped","text":"<p>KSP version to 1.0.11</p>"},{"location":"CHANGELOG/#120-2023-05-05","title":"1.2.0 - 2023-05-05","text":""},{"location":"CHANGELOG/#added_6","title":"Added","text":""},{"location":"CHANGELOG/#changed_6","title":"Changed","text":""},{"location":"CHANGELOG/#deprecated_6","title":"Deprecated","text":""},{"location":"CHANGELOG/#removed_6","title":"Removed","text":""},{"location":"CHANGELOG/#fixed_6","title":"Fixed","text":""},{"location":"CHANGELOG/#security_6","title":"Security","text":""},{"location":"CHANGELOG/#bumped_1","title":"Bumped","text":"<p>Now based on Ktor 2.3.0</p>"},{"location":"CHANGELOG/#110-2023-04-15","title":"1.1.0 - 2023-04-15","text":""},{"location":"CHANGELOG/#added_7","title":"Added","text":"<p>From now on there are two versions of the ktorfit-lib.</p> <p>\u201cde.jensklingenberg.ktorfit:ktorfit-lib\u201d will stay like before and add the platform client dependencies for the clients.</p> <p>\u201cde.jensklingenberg.ktorfit:ktorfit-lib-light\u201d this will only add the client core dependency and not the platform dependencies for the clients. This will give you more control over the used clients, but you have to add them yourself. https://ktor.io/docs/http-client-engines.html Everything else is the same as \u201cktorfit-lib\u201d</p>"},{"location":"CHANGELOG/#changed_7","title":"Changed","text":"<ul> <li>Kotlin version 1.8.20 is now needed</li> <li>KSP version 1.8.20-1.0.10 is now needed</li> </ul>"},{"location":"CHANGELOG/#deprecated_7","title":"Deprecated","text":""},{"location":"CHANGELOG/#removed_7","title":"Removed","text":""},{"location":"CHANGELOG/#fixed_7","title":"Fixed","text":""},{"location":"CHANGELOG/#security_7","title":"Security","text":""},{"location":"CHANGELOG/#bumped_2","title":"Bumped","text":"<ul> <li>Kotlin to 1.8.20</li> <li>KSP version to 1.8.20-1.0.10</li> </ul>"},{"location":"CHANGELOG/#101-2023-03-20","title":"1.0.1 - 2023-03-20","text":""},{"location":"CHANGELOG/#added_8","title":"Added","text":"<p>From now on there are two versions of the ktorfit-lib. </p> <p>\u201cde.jensklingenberg.ktorfit:ktorfit-lib\u201d will stay like before and add the platform client dependencies for the clients.</p> <p>\u201cde.jensklingenberg.ktorfit:ktorfit-lib-light\u201d this will only add the client core dependency and not the platform dependencies for the clients. This will give you more control over the used clients, but you have to add them yourself. https://ktor.io/docs/http-client-engines.html Everything else is the same as \u201cktorfit-lib\u201d</p>"},{"location":"CHANGELOG/#changed_8","title":"Changed","text":""},{"location":"CHANGELOG/#deprecated_8","title":"Deprecated","text":""},{"location":"CHANGELOG/#removed_8","title":"Removed","text":""},{"location":"CHANGELOG/#fixed_8","title":"Fixed","text":"<p>[Bug]: Post request body serialization doesn\u2019t work #202</p>"},{"location":"CHANGELOG/#security_8","title":"Security","text":""},{"location":"CHANGELOG/#bumped_3","title":"Bumped","text":""},{"location":"CHANGELOG/#100-2023-03-02","title":"1.0.0 - 2023-03-02","text":"<p>This project is now following semver</p>"},{"location":"CHANGELOG/#added_9","title":"Added","text":"<ul> <li>internal optimizations</li> <li>throw compile error when generated class can not be found</li> </ul>"},{"location":"CHANGELOG/#fixed_9","title":"Fixed","text":"<ul> <li>Timeout throws exception outside of scope of SuspendResponseConverter #127</li> <li>Fix broken/outdated docs link (#140) by @T-Spoon</li> </ul>"},{"location":"CHANGELOG/#bumped_4","title":"Bumped","text":"<ul> <li>based on Ktor 2.2.4</li> </ul>"},{"location":"CHANGELOG/#100-beta18-12-02-2023","title":"1.0.0-beta18 (12-02-2023)","text":"<p>NEW:</p> <ul> <li>You can now disable the check if the baseUrl ends with a /</li> </ul> <pre><code>Ktorfit.Builder().baseUrl(testBaseUrl, checkUrl = false).build()\n</code></pre> <p>\ud83d\udc1b Bugs fixed</p> <ul> <li>Fixed Ktorfit breaking incremental compilation #110</li> </ul> <p>\u2b06\ufe0f Deps updates</p> <ul> <li>based on Ktor 2.2.3</li> </ul>"},{"location":"CHANGELOG/#100-beta17-21-01-2023","title":"1.0.0-beta17 (21-01-2023)","text":"<p>\ud83d\udca5 Breaking changes:</p> <ul> <li>Ktorfit now needs an additional gradle plugin. This will solve several issues with multi-module projects.</li> </ul> <p>Add this plugin: <pre><code>plugins {\nid \"de.jensklingenberg.ktorfit\" version \"1.0.0\"\n}\n</code></pre></p> <p>NEW:</p> <ul> <li>interfaces can now be internal</li> </ul> <p>\ud83d\udc1b Bugs fixed</p> <ul> <li>Ktorfit multiple module support #92</li> <li>Add support for \u2018internal\u2019 parameter type #13</li> <li>Duplicate class KtorfitExtKt found in modules moduleA and moduleB #86</li> <li>Android overload resolution ambiguity #64</li> <li>Form data is double encoded #95</li> </ul> <p>\u2b06\ufe0f Deps updates</p> <ul> <li>based on Ktor 2.2.2</li> <li>Kotlin 1.8.0</li> <li>KSP 1.8.0-1.0.8</li> <li>update Android TargetSdk to 33</li> </ul>"},{"location":"CHANGELOG/#100-beta16-13-11-2022","title":"1.0.0-beta16 (13-11-2022)","text":"<p>NEW: - Field parameters can now be nullable, null values will be ignored in requests - Add option to turn of error checking</p> <p>ksp {   arg(\u201cKtorfit_Errors\u201d, \u201c1\u201d)   }</p> <p>You can set it in your build.gradle.kts file, </p> <p>0: Turn off all Ktorfit related error checking</p> <p>1: Check for errors</p> <p>2: Turn errors into warnings</p> <ul> <li>Added RequestConverter support #84</li> </ul> <p>\u2b06\ufe0f Deps updates</p> <ul> <li>based on Ktor 2.1.3</li> <li>Kotlin 1.7.21</li> <li>KSP 1.0.8</li> <li>update Android TargetSdk to 33</li> </ul> <p>\ud83d\udc1b Bugs fixed</p> <ul> <li>FlowResponseConverter #81</li> </ul>"},{"location":"CHANGELOG/#whats-changed","title":"What\u2019s Changed","text":"<ul> <li>build(deps): bump logback-classic from 1.4.0 to 1.4.3 by @dependabot in https://github.com/Foso/Ktorfit/pull/74</li> <li>Foso/revert converters changes by @Foso in https://github.com/Foso/Ktorfit/pull/76</li> <li>67 add nullable field parameters support by @Foso in https://github.com/Foso/Ktorfit/pull/80</li> <li>fix: FlowResponseConverter by @Foso in https://github.com/Foso/Ktorfit/pull/81</li> <li>Added RequestConverter support by @DATL4G in https://github.com/Foso/Ktorfit/pull/84</li> <li>feat: add option to turn off error checking #77 by @Foso in https://github.com/Foso/Ktorfit/pull/88</li> </ul> <p>Full Changelog: https://github.com/Foso/Ktorfit/compare/v1.0.0-beta15...v1.0.0-beta16</p>"},{"location":"CHANGELOG/#100-beta15-05-10-2022","title":"1.0.0-beta15 (05-10-2022)","text":"<p>\u2b06\ufe0f Deps updates</p> <ul> <li>based on Ktor 2.1.2</li> </ul> <p>\ud83d\udc1b Bugs fixed</p> <ul> <li>kotlinx.coroutines.JobCancellationException: Parent job is Completed #70</li> </ul> <p>\ud83d\udca5 Breaking changes</p> <ul> <li>reverted the api of converters to the state of beta13, see #71 </li> <li>when you are updating from beta13, this is the only change to converters:   returnTypeName is replaced through typeData, you can use typeData.qualifiedName to get the same value as returnTypeName</li> </ul>"},{"location":"CHANGELOG/#100-beta14-24-09-2022","title":"1.0.0-beta14 (24-09-2022)","text":"<p>NEW: - Query parameters can now be nullable, null values will be ignored in requests - Function return types can now be nullable</p> <p>FIX: - Url annotation not resolved correctly #65</p> <p>BREAKING CHANGES: - Changed naming of Converters:</p> <ul> <li>SuspendResponseConverter:<ul> <li>is now called RequestConverter</li> <li>the wrapSuspendResponse is now called convertRequest.</li> <li>returnTypeName is replaced through typeData, you can use typeData.qualifiedName to get the same value as returnTypeName   RequestConverter need to be added with the requestConverter() on your Ktorfit object.</li> <li>https://foso.github.io/Ktorfit/requestconverter/</li> </ul> </li> <li>ResponseConverters:<ul> <li>returnTypeName is replaced through typeData, you can use typeData.qualifiedName to get the same value as returnTypeName   https://foso.github.io/Ktorfit/responseconverter/</li> </ul> </li> </ul>"},{"location":"CHANGELOG/#100-beta13-10-09-2022","title":"1.0.0-beta13 (10-09-2022)","text":"<ul> <li>KtorfitCallResponseConverter and KtorfitSuspendCallResponseConverter are now combined in KtorfitCallResponseConverter</li> <li>based on Ktor 2.1.1</li> </ul> <p>Fixed: - Url annotation not resolved correctly #52</p>"},{"location":"CHANGELOG/#100-beta12-31-08-2022","title":"1.0.0-beta12 (31-08-2022)","text":""},{"location":"CHANGELOG/#breaking-changes","title":"Breaking Changes:","text":"<p>wrapResponse from SuspendResponseConverter got renamed to wrapSuspendResponse. This add the possibility to have ResponseConverter and SuspendResponseConverter implemented in the same class.</p>"},{"location":"CHANGELOG/#changes","title":"Changes:","text":"<ul> <li>throw compiler time error when you use @Path without the corresponding value inside the relative url path</li> <li>every generated implementation class of an interface that Ktorfit generates will now contain a \u201ccreate\u201d ext function that can be used instead of the generic create() function e.g. Let\u2019s say you have a interface GithubService, then you can create an instance like this:</li> </ul> <p><pre><code>val ktorfit = ktorfit {\nbaseUrl(\"http://example.com/\")\n}.create&lt;GithubService&gt;()\n</code></pre> or this</p> <pre><code>val ktorfit = ktorfit {\nbaseUrl(\"http://example.com/\")\n}.createGithubService()\n</code></pre> <p>By default, IntelliJ/Android Studio can\u2019t find the generated code, you need to add the KSP generated folder to the sourcesets  like this: (See more here: https://kotlinlang.org/docs/ksp-quickstart.html#make-ide-aware-of-generated-code)</p> <pre><code>kotlin.srcDir(\"build/generated/ksp/jvm/jvmMain/\")\n</code></pre>"},{"location":"CHANGELOG/#100-beta11-21-08-2022","title":"1.0.0-beta11 (21-08-2022)","text":"<ul> <li>you can now use ResponseConverter in combination with suspend functions. Implement the SuspendResponseConverter</li> <li>KtorfitCallResponseConverter and FlowResponseConverter moved to de.jensklingenberg.ktorfit.converter.builtin</li> </ul>"},{"location":"CHANGELOG/#100-beta10-18-08-2022","title":"1.0.0-beta10 (18-08-2022)","text":"<ul> <li>based on Ktor 2.0.2</li> <li>added windows target #26</li> <li>@PATCH, @POST, @PUT now have a default value #22</li> <li>Ktorfit now uses a builder pattern for setup  e.g. change this:   <code>kotlin  Ktorfit(\"https://example.com/\", HttpClient {})</code></li> </ul> <p>to this: </p> <pre><code>Ktorfit.Builder()\n.baseUrl(\"https://example.com/\")\n.httpClient(HttpClient {})\n.build()\n</code></pre> <ul> <li></li> </ul>"},{"location":"CHANGELOG/#breaking-changes_1","title":"Breaking Changes:","text":"<p>@Headers now requires a vararg of String instead of an Array e.g. you need to change from:</p> <pre><code>@Headers(\n[\"Authorization: token ghp_abcdefgh\",\n\"Content-Type: application/json\"]\n)\n</code></pre> <p>to this: <pre><code>@Headers(\n\"Authorization: token ghp_abcdefgh\",\n\"Content-Type: application/json\"\n)\n</code></pre></p>"},{"location":"CHANGELOG/#100-beta09","title":"1.0.0-beta09","text":""},{"location":"CHANGELOG/#15-fix-encoding-of-query-parameters","title":"15 fix encoding of query parameters","text":""},{"location":"CHANGELOG/#100-beta08","title":"1.0.0-beta08","text":"<ul> <li>fix issue with Koin Annotations</li> </ul>"},{"location":"CHANGELOG/#100-beta07","title":"1.0.0-beta07","text":"<ul> <li>fix issue with FormUrlEncoded</li> <li>based on Ktor 2.0.2</li> </ul>"},{"location":"CHANGELOG/#100-beta06","title":"1.0.0-beta06","text":"<ul> <li>fix issue with KSP 1.0.5 #19</li> </ul>"},{"location":"CHANGELOG/#100-beta05","title":"1.0.0-beta05","text":"<ul> <li>fixed: Custom Http Method with @Body is now possible #6</li> <li>based on Ktor 2.0.1</li> <li>cleanup example project @mattrob33</li> </ul>"},{"location":"CHANGELOG/#100-beta04","title":"1.0.0-beta04","text":"<p>initial release</p>"},{"location":"License/","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\u201cLicense\u201d shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\u201cLicensor\u201d shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\u201cLegal Entity\u201d shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \u201ccontrol\u201d means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\u201cYou\u201d (or \u201cYour\u201d) shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\u201cSource\u201d form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\u201cObject\u201d form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\u201cWork\u201d shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\u201cDerivative Works\u201d shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\u201cContribution\u201d shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \u201csubmitted\u201d   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \u201cNot a Contribution.\u201d</p> <p>\u201cContributor\u201d shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>\u00a9 You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \u201cNOTICE\u201d text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \u201cAS IS\u201d BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright 2022 Jens Klingenberg</p> <p>Licensed under the Apache License, Version 2.0 (the \u201cLicense\u201d);    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \u201cAS IS\u201d BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"architecture/","title":"How Ktorfit works under the hood","text":"<p>Ktorfit consists of three main components KSP-Plugin, Compiler plugin and the Ktorfit lib</p>"},{"location":"architecture/#ksp-plugin","title":"KSP-Plugin","text":"<p>This will generate the code for the implementation of the interfaces</p>"},{"location":"architecture/#compiler-plugin","title":"Compiler plugin","text":"<p>This transforms the create() function from the Ktorfit lib</p>"},{"location":"architecture/#ktorfit-lib","title":"Ktorfit lib","text":"<p>A wrapper around Ktor to simplify code generation</p>"},{"location":"architecture/#example","title":"Example","text":"<p><pre><code>package com.example\n\nimport com.example.model.People\nimport de.jensklingenberg.ktorfit.http.GET\n\ninterface ExampleApi  {\n@GET(\"/test\")\nsuspend fun exampleGet(): People\n}\n</code></pre> Let`s say we have a interface like this.</p> <p>At compile time Ktorfit/KSP checks for all functions that are annotated with Ktorfit annotations like @GET.</p> <p>Then it looks at the parent interfaces of that functions and generates, the source code of a Kotlin class that implements the interface. The classes are named like the interfaces but with an underscore at the beginning and \u201cImpl\u201d at the end, and they have the same package as the interfaces. In this case a class named _ExampleApiImpl will be generated. The class will also implement KtorfitService. The setClient() function will be used to add the http client at runtime.</p> <pre><code>@OptIn(InternalKtorfitApi::class)\npublic class _ExampleApiImpl : ExampleApi, KtorfitService {\npublic override lateinit var ktorfitClient: Client\n\npublic override suspend fun exampleGet(): String {\nval _ext: HttpRequestBuilder.() -&gt; Unit = {\nmethod = HttpMethod.parse(\"GET\")\nurl(ktorfitClient.baseUrl + \"/test\")\n}\nval _requestData = RequestData(returnTypeData = TypeData(\"kotlin.String\"),\nrequestTypeInfo = typeInfo&lt;String&gt;(),\nreturnTypeInfo = typeInfo&lt;String&gt;(),\nktorfitRequestBuilder = _ext)\n\nreturn ktorfitClient.suspendRequest&lt;String, String&gt;(_requestData)!!\n}\n}\n\npublic fun Ktorfit.createExampleApi(): ExampleApi = this.create(_ExampleApiImpl())\n</code></pre> <p>The next part is the compiler plugin which is added by the gradle plugin. It looks for the every usage of the create function from the Ktorfit-lib and adds an object of the  wanted implementation class as an argument. Because of the naming convention of the generated classes we can deduce the name of the class from the name of type parameter.</p> <pre><code>val api = jvmKtorfit.create&lt;ExampleApi&gt;()\n</code></pre> <p>will be transformed to: </p> <pre><code>val api = jvmKtorfit.create&lt;ExampleApi&gt;(_ExampleApiImpl())\n</code></pre> <p>When the create() function is used, the object is cast to a KtorfitService and the client will be added. Then it is cast to requested type &lt; T &gt;</p> <pre><code>fun &lt;T&gt; create(ktorfitService: KtorfitService = DefaultKtorfitService()): T {\nif (ktorfitService is DefaultKtorfitService) {\nthrow IllegalArgumentException(\"You need to enable the Ktorfit Gradle Plugin\")\n}\nktorfitService.setClient(KtorfitClient(this))\nreturn ktorfitService as T\n}\n</code></pre>"},{"location":"configuration/","title":"Compile errors","text":"<p>By default, Ktorfit will throw compile error when it finds conditions under which it can\u2019t ensure that it will work correct. You can set an KSP argument to change this:</p> <pre><code>ksp {\narg(\"Ktorfit_Errors\", \"1\")\n}\n</code></pre> <p>You can set it in your build.gradle.kts file,</p> <p>0: Turn off all Ktorfit related error checking</p> <p>1: Check for errors</p> <p>2: Turn errors into warnings</p>"},{"location":"configuration/#add-your-own-ktor-client","title":"Add your own Ktor client","text":"<p>You can set your Ktor client instance to the Ktorfit builder:</p> <pre><code>val myClient = HttpClient()\nval ktorfit = Ktorfit.Builder().httpClient(myClient).build()\n</code></pre>"},{"location":"development/","title":"Development","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#setup","title":"Setup","text":"<p>(You can also look how it\u2019s done in the examples)</p>"},{"location":"installation/#gradle-plugins","title":"Gradle Plugins","text":"<p>You need to add KSP and the Ktorfit Gradle plugin <pre><code>plugins {\nid(\"com.google.devtools.ksp\") version \"CURRENT_KSP_VERSION\"\nid(\"de.jensklingenberg.ktorfit\") version \"1.0.0\"\n}\n\nconfigure&lt;de.jensklingenberg.ktorfit.gradle.KtorfitGradleConfiguration&gt; {\nversion = \"1.4.3\"\n}\n</code></pre></p> <p>Next you have to add the Ktorfit KSP Plugin to the common target and every compilation target, where you want to use Ktorfit.</p> <pre><code>val ktorfitVersion = \"1.4.3\"\n\ndependencies {\nadd(\"kspCommonMainMetadata\", \"de.jensklingenberg.ktorfit:ktorfit-ksp:$ktorfitVersion\")\nadd(\"ksp[NAMEOFPLATFORM]\",\"de.jensklingenberg.ktorfit:ktorfit-ksp:$ktorfitVersion\")\n...\n}\n</code></pre> <p>[NAMEOFPLATFORM] is the name of the compilation target. When you want to use it for the Android module it\u2019s kspAndroid, for Js it\u2019s kspJs, etc. Look here for more information https://kotlinlang.org/docs/ksp-multiplatform.html</p>"},{"location":"installation/#ktorfit-lib","title":"Ktorfit-lib","text":"<p>Add the Ktorfit-lib to your common module. <pre><code>val ktorfitVersion = \"1.4.3\"\n\nsourceSets {\nval commonMain by getting{\ndependencies{\nimplementation(\"de.jensklingenberg.ktorfit:ktorfit-lib:$ktorfitVersion\")\n}\n}\n</code></pre></p>"},{"location":"installation/#ktor","title":"Ktor","text":"<p>Ktorfit is based on Ktor clients 2.3.1. You don\u2019t need to add an extra dependency for the default clients. When you want to use Ktor plugins for things like serialization, you need to add the dependencies, and they need to be compatible with 2.3.1</p> <p>You can also use \u201cde.jensklingenberg.ktorfit:ktorfit-lib-light\u201d this will only add the Ktor client core dependency and not the platform dependencies for the clients. This will give you more control over the used clients, but you have to add them yourself. https://ktor.io/docs/http-client-engines.html Everything else is the same as \u201cktorfit-lib\u201d</p>"},{"location":"quick-start/","title":"Quick start","text":"<p>First do the Installation</p> <p>Let\u2019s say you want to make a GET Request to https://swapi.dev/api/people/1/</p> <p>Create a new Kotlin interface:</p> <pre><code>interface ExampleApi {\n@GET(\"people/1/\")\nsuspend fun getPerson(): String\n}\n</code></pre> <p>Now we add a function that will be used to make our request. The @GET annotation will tell Ktorfit that this a GET request. The value of @GET is the relative URL path that will be appended to the base url which we set later.</p> <p>An interface used for Ktorfit needs to have a HTTP method annotation on every function. Because Ktor relies on Coroutines by default your functions need to have the suspend modifier. Alternatively you can use #Flow or Call</p> <p>Info</p> <p>The return type String will return the response text. When you want directly parse the response into a class you need to add a JSON,XML, etc. converter to Ktor</p> <pre><code>val ktorfit = Ktorfit.Builder().baseUrl(\"https://swapi.dev/api/\").build()\nval exampleApi = ktorfit.create&lt;ExampleApi&gt;()\n</code></pre> <p>Next we use the Ktorfit builder to create a Ktorfit instance, and set the base url . We can then use the create() function to receive an implementation of the wanted type.</p> <pre><code>val response = exampleApi.getPerson()\nprintln(response)\n</code></pre> <p>Now we can use exampleApi to make the request.</p>"},{"location":"requests/","title":"Requests","text":""},{"location":"requests/#http-request","title":"HTTP Request","text":"<p>Ktorfit supports the following the HTTP method annotations:</p> <ul> <li>@GET</li> <li>@POST</li> <li>@PUT</li> <li>@DELETE</li> <li>@HEAD</li> <li>@OPTIONS</li> <li>@PATCH</li> </ul> <p>Or you can set your custom method to @HTTP</p> <pre><code>@GET(\"posts\")\nfun getPosts(): List&lt;Post&gt;\n</code></pre> <p>The value of the HTTP annotation will be appended to the baseUrl that you set in the Ktorfit builder. If the value contains a url that starts with http or https, this url will be used for the request instead of the baseUrl.</p> <pre><code>@GET(\"https://example.com/posts\")\nfun getPosts(): List&lt;Post&gt;\n</code></pre> <p>The value can only be empty when you also use @Url</p>"},{"location":"requests/#url","title":"Url","text":"<p>Can be used to set a URL dynamically as a function parameter. <pre><code>@GET(\"\")\nsuspend fun getPosts(@Url url: String): List&lt;Post&gt;\n</code></pre></p>"},{"location":"requests/#query","title":"Query","text":"<pre><code>@GET(\"comments\")\nsuspend fun getCommentsById(\n@Query(\"postId\") postId: String,\n@QueryName queryName: String,\n@QueryMap headerMap : Map&lt;String,String&gt;\n): List&lt;Comment&gt;\n</code></pre> <p>You can use @Query, @QueryName or @QueryMap to set queries to your request.</p> <p>Example: <pre><code>@GET(\"comments\")\nsuspend fun getCommentsById(@Query(\"postId\") postId: String): List&lt;Comment&gt;\n</code></pre></p> <p>A request with getCommentsById(3) will result in the relative URL \u201ccomments?postId=3\u201d</p>"},{"location":"requests/#path","title":"Path","text":"<p>When you want to dynamically replace a part of the URL, you can use the @Path annotation. <pre><code>interface ExampleApi {\n@GET(\"people/{peopleId}/\")\nsuspend fun getPerson(@Path(\"peopleId\") id: String): String\n}\n</code></pre> Just write a part of your URL path in curly braces. Then you need to annotate a parameter with @Path. The value of @Path needs to match with one of the curly braces part in your URL path.</p> <p>Example:</p> <p>On a request with getPerson(1) , {peopleId} will be replaced with the argument 1 and the relative URL will become \u201cpeople/1/\u201d</p>"},{"location":"requests/#headers","title":"Headers","text":"<pre><code>@Headers(\"Accept: application/json\")\n@GET(\"comments\")\nsuspend fun requestWithHeaders(\n@Header(\"Content-Type\") name: String,\n@HeaderMap headerMap : Map&lt;String,String&gt;\n): List&lt;Comment&gt;\n</code></pre> <p>You can use @Headers, @Header or @HeaderMap to configure headers to your request.</p>"},{"location":"requests/#body","title":"Body","text":"<pre><code>interface ExampleService {\n@POST(\"upload\")\nsuspend fun upload(@Body data: String)\n}\n</code></pre> <p>@Body can be used as parameter to send data in a request body. It can only be used with Http Methods that have a request body</p>"},{"location":"requests/#formdata","title":"FormData","text":"<pre><code>@POST(\"signup\")\n@FormUrlEncoded\nsuspend fun signup(\n@Field(\"username\") username: String, @Field(\"email\") email: String,\n@Field(\"password\") password: String, @Field(\"confirmation\") confirmation: String\n): String\n</code></pre> <p>To send FormData you can use @Field or @FieldMap. Your function needs to be annotated with @FormUrlEncoded.</p>"},{"location":"requests/#multipart","title":"Multipart","text":"<p>To send Multipart data you have two options:</p>"},{"location":"requests/#1-body","title":"1) @Body","text":"<pre><code>interface ExampleService {\n@POST(\"upload\")\nsuspend fun upload(@Body map: MultiPartFormDataContent)\n}\n</code></pre> <p>To upload MultiPartFormData you need to have a parameter of the type MultiPartFormDataContent that is annotated with @Body. The method needs to be annotated with @POST or @PUT</p> <pre><code>val multipart = MultiPartFormDataContent(formData {\nappend(\"description\", \"Ktor logo\")\nappend(\"image\", File(\"ktor_logo.png\").readBytes(), Headers.build {\nappend(HttpHeaders.ContentType, \"image/png\")\nappend(HttpHeaders.ContentDisposition, \"filename=ktor_logo.png\")\n})\n})\n\nexampleApi.upload(multipart)\n</code></pre> <p>Then you can use Ktor\u2019s formData Builder to create the MultiPartFormDataContent</p>"},{"location":"requests/#2-multipart","title":"2) @MultiPart","text":"<pre><code>@Multipart\n@POST(\"upload\")\nsuspend fun uploadFile(@Part(\"description\") description: String, @Part(\"\") file: List&lt;PartData&gt;): String\n</code></pre> <p>You can annotate a function with @Multipart. Then you can annotate parameters with @Part</p> <pre><code>val multipart = formData {\nappend(\"image\", File(\"ktor_logo.png\").readBytes(), Headers.build {\nappend(HttpHeaders.ContentType, \"image/png\")\nappend(HttpHeaders.ContentDisposition, \"filename=ktor_logo.png\")\n})\n}\n\nexampleApi.upload(\"Ktor logo\",multipart)\n</code></pre> <p>All your parameters annotated with @Part wil be combined and send as MultiPartFormDataContent</p>"},{"location":"requests/#json","title":"JSON","text":"<p>Ktorfit doesn\u2019t parse JSON. You have to install the Json Feature to the Ktor Client that you add to Ktorfit.</p> <p>See here Add your own Ktor client and here https://ktor.io/docs/serialization-client.html</p> <pre><code>val ktorClient = HttpClient() {\ninstall(ContentNegotiation) {\njson(Json { isLenient = true; ignoreUnknownKeys = true })\n}\n}\n</code></pre>"},{"location":"requests/#streaming","title":"Streaming","text":"<pre><code>@Streaming\n@GET(\"docs/response.html#streaming\")\nsuspend fun getPostsStreaming(): HttpStatement\n</code></pre> <p>To receive streaming data you need to annotate a function with @Streaming and the return type has to be HttpStatement.</p> <pre><code>exampleApi.getPostsStreaming().execute { response -&gt;\n//Do something with response\n}\n</code></pre> <p>For more information check Ktor docs</p>"},{"location":"requests/#requestbuilder","title":"RequestBuilder","text":"<pre><code>@GET(\"comments\")\nsuspend fun getCommentsById(\n@Query(\"postId\") name: String,\n@ReqBuilder ext: HttpRequestBuilder.() -&gt; Unit\n): List&lt;Comment&gt;\n</code></pre> <p>You need to set extra configuration on your request? Add a parameter with \u201c@ReqBuilder ext: HttpRequestBuilder.() -&gt; Unit\u201d to your function. <pre><code>val result = secondApi.getCommentsById(\"3\") {\nonDownload { bytesSentTotal, contentLength -&gt;\nprintln(bytesSentTotal)\n}\n}\n</code></pre></p> <p>Then you can use the extension function to set additional configuration. The RequestBuilder will be applied last after everything that is set by Ktorfit</p>"},{"location":"responseconverter/","title":"Responseconverter","text":"<p>ResponseConverter is deprecated, use Converter.ResponseConverter instead</p> <p>Let`s say you have a function that requests a list of comments</p> <pre><code>@GET(\"posts/{postId}/comments\")\nsuspend fun getCommentsByPostId(@Path(\"postId\") postId: Int): List&lt;Comment&gt;\n</code></pre> <p>But now you want to directly wrap your comment list in your data holder class e.g. \u201cMyOwnResponse\u201d</p> <pre><code>sealed class MyOwnResponse&lt;T&gt; {\ndata class Success&lt;T&gt;(val data: T) : MyOwnResponse&lt;T&gt;()\nclass Error(val ex:Throwable) : MyOwnResponse&lt;Nothing&gt;()\n\ncompanion object {\nfun &lt;T&gt; success(data: T) = Success(data)\nfun error(ex: Throwable) = Error(ex)\n}\n}\n</code></pre> <p>To enable that, you have to implement a ResponseConverter. This class will be used to wrap the Ktor response inside your wrapper class.</p> <pre><code>class MyOwnResponseConverter : ResponseConverter {\n\noverride suspend fun &lt;RequestType&gt; wrapResponse(\ntypeData: TypeData,\nrequestFunction: suspend () -&gt; Pair&lt;TypeInfo, HttpResponse&gt;,\nktorfit: Ktorfit\n): Any {\nreturn try {\nval (info, response) = requestFunction()\nMyOwnResponse.success&lt;Any&gt;(response.body(info))\n} catch (ex: Throwable) {\nMyOwnResponse.error(ex)\n}\n}\n\noverride fun supportedType(typeData: TypeData, isSuspend: Boolean): Boolean {\nreturn typeData.qualifiedName == \"com.example.model.MyOwnResponse\"\n}\n}\n</code></pre> <p>You can then add the ResponseConverter on your Ktorfit object.</p> <pre><code>ktorfit.responseConverter(MyOwnResponseConverter())\n</code></pre> <p>Now add MyOwnResponse to your function <pre><code>@GET(\"posts/{postId}/comments\")\nsuspend fun getCommentsByPostId(@Path(\"postId\") postId: Int): MyOwnResponse&lt;List&lt;Comment&gt;&gt;\n</code></pre></p>"},{"location":"suspendresponseconverter/","title":"Suspendresponseconverter","text":"<p>SuspendResponseConverter is deprecated, use Converter.SuspendResponseConverter instead</p> <p>Because Ktor relies on Coroutines by default your functions need to have the suspend modifier.</p> <p>To change this, you need to use a SuspendResponseConverter, you add your own or use Flow or Call</p> <p>You can add RequestConverter on your Ktorfit object.</p> <pre><code>ktorfit.responseConverter(FlowResponseConverter())\n</code></pre>"},{"location":"suspendresponseconverter/#flow","title":"Flow","text":"<p>Ktorfit has support for Kotlin Flow. You need add the FlowResponseConverter() to your Ktorfit instance.</p> <pre><code>ktorfit.responseConverter(FlowResponseConverter())\n</code></pre> <pre><code>@GET(\"comments\")\nfun getCommentsById(@Query(\"postId\") postId: String): Flow&lt;List&lt;Comment&gt;&gt;\n</code></pre> <p>Then you can drop the suspend modifier and wrap your return type with Flow&lt;&gt;</p>"},{"location":"suspendresponseconverter/#call","title":"Call","text":"<p><pre><code>ktorfit.responseConverter(CallResponseConverter())\n</code></pre> <pre><code>@GET(\"people/{id}/\")\nfun getPersonById(@Path(\"id\") peopleId: Int): Call&lt;People&gt;\n</code></pre></p> <pre><code>exampleApi.getPersonById(3).onExecute(object : Callback&lt;People&gt;{\noverride fun onResponse(call: People, response: HttpResponse) {\n//Do something with Response\n}\n\noverride fun onError(exception: Exception) {\n//Do something with exception\n}\n})\n</code></pre> <p>You can use Call to receive the response in a Callback."},{"location":"suspendresponseconverter/#your-own","title":"Your own","text":"<p>You can also add your own Converter. You just need to implement RequestConverter. Inside the converter you need to handle the conversion from suspend to your async code.</p> <pre><code>class MyOwnResponseConverter : SuspendResponseConverter {\n...\n</code></pre>"},{"location":"converters/converters/","title":"Converters","text":"<p>Converters are used to convert the HTTPResponse  or parameters.</p> <p>They are added inside of a Converter.Factory which will then be added to the Ktorfit builder with the converterfactories() function.</p>"},{"location":"converters/converters/#converter-types","title":"Converter Types","text":"<ul> <li>ResponseConverters</li> <li>SuspendResponseConverter</li> <li>RequestParameterConverter</li> </ul>"},{"location":"converters/converters/#existing-converter-factories","title":"Existing converter factories","text":"<ul> <li>CallConverterFactory</li> <li>FlowConverterFactoy</li> </ul>"},{"location":"converters/example1/","title":"Example1","text":"<p>Let\u2019s say you want to get an user from an API and the response you get looks like below:</p> API response<pre><code>{\n\"success\": true,\n\"user\":\n{\n\"id\": 1,\n\"name\": \"Jens Klingenberg\"\n}\n}\n</code></pre> <p>But you are only interested in the \u201cuser\u201d object, and you want to look your interface function something like this:</p> Example function<pre><code>@GET(\"/user\")\nsuspend fun getUser(): User\n</code></pre> <p>First you need the Kotlin classes to which your JSON data is mapped to:</p> <p>This example assumes that you are Kotlin Serialization</p> <pre><code>@kotlinx.serialization.Serializable\ndata class Envelope(val success: Boolean, val user: User)\n\n@kotlinx.serialization.Serializable\ndata class User(val id: Int, val name: String)\n</code></pre> <p>Now you need a converter that can convert the HTTPResponse and return a user object. Create a class that extends Converter.Factory</p> <pre><code>class UserFactory : Converter.Factory {\n\n}\n</code></pre> <p>Because in this case User is the return type of a suspend function, you need to create a SuspendResponseConverter. Override suspendResponseConverter()</p> <pre><code>class UserFactory : Converter.Factory {\noverride fun suspendResponseConverter(\ntypeData: TypeData,\nktorfit: Ktorfit\n): Converter.SuspendResponseConverter&lt;HttpResponse, *&gt;? {\n\n}\n}\n</code></pre> <p>Inside suspendResponseConverter you can decide if you want to return a converter. In our case we a converter for the type User. We can check that case with the typeData that we get as a parameter.</p> <pre><code>override fun suspendResponseConverter(\ntypeData: TypeData,\nktorfit: Ktorfit\n): Converter.SuspendResponseConverter&lt;HttpResponse, *&gt;? {\nif (typeData.typeInfo.type == User::class) {\n...\n}\nreturn null\n}\n</code></pre> <p>Next we create the SuspendResponseConverter: <pre><code>if (typeData.typeInfo.type == User::class) {\nreturn object : Converter.SuspendResponseConverter&lt;HttpResponse, Any&gt; {\noverride suspend fun convert(response: HttpResponse): Any {\n...\n}\n}\n}\n</code></pre> Inside of convert we get the HttpResponse and we want to return a User object.</p> <p>Now we could do the following:</p> <p>When we know that this converter will always be used for a API that wraps the User inside an Envelope class, we can directly transform the body to an envelope object and just return the user object.</p> <pre><code>override suspend fun convert(response: HttpResponse): Any {\nval envelope = response.body&lt;Envelope&gt;()\nreturn envelope.user\n}\n</code></pre> <p>or we can create a TypeData of Envelope and use nextSuspendResponseConverter() to look up the next converter that can convert the response</p> <pre><code> override suspend fun convert(response: HttpResponse): Any {\nval typeData = TypeData.createTypeData(\"com.example.model.Envelope\", typeInfo&lt;Envelope&gt;())\nval envelope = ktorfit.nextSuspendResponseConverter(null, typeData)?.convert(response) as? Envelope\nreturn envelope.user\n}\n</code></pre> <p>Finally, add your converter factory to the Ktorfit Builder </p> <pre><code>Ktorfit.Builder().converterFactories(UserFactory()).baseUrl(\"foo\").build()\n</code></pre>"},{"location":"converters/migration/","title":"Migration","text":"<ul> <li>SuspendResponseConverter -&gt; Converter.SuspendResponseConverter</li> </ul> SuspendResponseConverter<pre><code> override suspend fun &lt;RequestType&gt; wrapSuspendResponse(\ntypeData: TypeData,\nrequestFunction: suspend () -&gt; Pair&lt;TypeInfo, HttpResponse&gt;,\nktorfit: Ktorfit\n): Any {\nreturn object : Call&lt;RequestType&gt; {\noverride fun onExecute(callBack: Callback&lt;RequestType&gt;) {\n\nktorfit.httpClient.launch {\nval deferredResponse = async { requestFunction() }\n\nval (data, response) = deferredResponse.await()\n\ntry {\nval res = response.call.body(data)\ncallBack.onResponse(res as RequestType, response)\n} catch (ex: Exception) {\ncallBack.onError(ex)\n} } } } }\n\noverride fun supportedType(typeData: TypeData, isSuspend: Boolean): Boolean {\nreturn typeData.qualifiedName == \"de.jensklingenberg.ktorfit.Call\"\n}\n</code></pre> Equivalent with converter factory:<pre><code>public class CallConverterFactory : Converter.Factory {\n\noverride fun suspendResponseConverter(\ntypeData: TypeData,\nktorfit: Ktorfit\n): Converter.SuspendResponseConverter&lt;HttpResponse, *&gt;? {\nif (typeData.typeInfo.type == Call::class) {\nreturn object: Converter.SuspendResponseConverter&lt;HttpResponse, Call&lt;Any?&gt;&gt; {\noverride suspend fun convert(response: HttpResponse): Call&lt;Any?&gt; {\n\nreturn object : Call&lt;Any?&gt; {\noverride fun onExecute(callBack: Callback&lt;Any?&gt;) {\nktorfit.httpClient.launch {\ntry {\nval data = response.call.body(typeData.typeArgs.first().typeInfo)\ncallBack.onResponse(data!!, response)\n} catch (ex: Exception) {\ncallBack.onError(ex)\n} } } } } } }\nreturn null\n}\n}\n</code></pre> <ul> <li>ResponseConverter -&gt; Converter.ResponseConverter</li> </ul> ResponseConverter<pre><code>override fun &lt;RequestType&gt; wrapResponse(\ntypeData: TypeData,\nrequestFunction: suspend () -&gt; Pair&lt;TypeInfo, HttpResponse?&gt;,\nktorfit: Ktorfit\n): Any {\nreturn object : Call&lt;RequestType&gt; {\noverride fun onExecute(callBack: Callback&lt;RequestType&gt;) {\n\nktorfit.httpClient.launch {\nval deferredResponse = async { requestFunction() }\n\ntry {\nval (info, response) = deferredResponse.await()\nval data = response!!.body(info) as RequestType\ncallBack.onResponse(data, response)\n} catch (ex: Exception) {\ncallBack.onError(ex)\n}\n\n}\n}\n\n}\n}\n\noverride fun supportedType(typeData: TypeData, isSuspend: Boolean): Boolean {\nreturn typeData.qualifiedName == \"de.jensklingenberg.ktorfit.Call\"\n}\n</code></pre> Equivalent with converter factory:<pre><code>public class CallConverterFactory : Converter.Factory {\noverride fun responseConverter(\ntypeData: TypeData,\nktorfit: Ktorfit\n): Converter.ResponseConverter&lt;HttpResponse, *&gt;? {\nif (typeData.typeInfo.type == Call::class) {\nreturn object : Converter.ResponseConverter&lt;HttpResponse, Call&lt;Any?&gt;&gt; {\n\noverride fun convert(getResponse: suspend () -&gt; HttpResponse): Call&lt;Any?&gt; {\nreturn object : Call&lt;Any?&gt; {\noverride fun onExecute(callBack: Callback&lt;Any?&gt;) {\nktorfit.httpClient.launch {\ntry {\nval response = getResponse()\n\nval data = response.call.body(typeData.typeArgs.first().typeInfo)\n\ncallBack.onResponse(data, response)\n} catch (ex: Exception) {\nprintln(ex)\ncallBack.onError(ex)\n} } } } } } }\nreturn null\n}\n}\n</code></pre>"},{"location":"converters/requestparameterconverter/","title":"RequestParameterConverter","text":"<pre><code>@GET(\"posts/{postId}/comments\")\nsuspend fun getCommentsById(@RequestType(Int::class) @Path(\"postId\") postId: String): List&lt;Comment&gt;\n</code></pre> <p>You can set RequestType at a parameter with a type to which the parameter should be converted.</p> <p>Then you need to implement a Converter factory with a RequestParameterConverter. </p> <pre><code>class StringToIntRequestConverterFactory : Converter.Factory {\noverride fun requestParameterConverter(\nparameterType: KClass&lt;*&gt;,\nrequestType: KClass&lt;*&gt;\n): Converter.RequestParameterConverter? {\nreturn object : Converter.RequestParameterConverter {\noverride fun convert(data: Any): Any {\n//convert the data\n}\n}\n}\n}\n</code></pre> <pre><code>ktorfit.converterFactories(StringToIntRequestConverterFactory())\n</code></pre>"},{"location":"converters/responseconverter/","title":"ResponseConverter","text":"<p>You only need ResponseConverters for cases where you can\u2019t use a suspend function in your interface. For every other case you want SuspendResponseConverter</p> <p>Because Ktor relies on Coroutines by default your functions need to have the suspend modifier.</p> <p>Let\u2019s say you have API endpoint to get a list of comments and you want to get them as Flow.</p> <p>Ktorfit already has a converter for Flow, but it\u2019s used as an example</p> <pre><code>@GET(\"/user\")\nfun getUser(): Flow&lt;List&lt;Commment&gt;&gt;\n</code></pre> <p>Now you need a converter that can convert the HTTPResponse and return a Flow. Create a class that extends Converter.Factory</p> <pre><code>class FlowConverterFactory : Converter.Factory {\n}\n</code></pre> <p>Next you need to overwrite responseConverter()</p> <pre><code>override fun responseConverter(\ntypeData: TypeData,\nktorfit: Ktorfit\n): Converter.ResponseConverter&lt;HttpResponse, *&gt;? {\n</code></pre> <p>Inside responseConverter you can decide if you want to return a converter. In our case we want a converter for the type Flow. We can check that case with the typeData that we get as a parameter.</p> <pre><code>override fun suspendResponseConverter(\ntypeData: TypeData,\nktorfit: Ktorfit\n): Converter.SuspendResponseConverter&lt;HttpResponse, *&gt;? {\nif (typeData.typeInfo.type == Flow::class) {\n...\n}\nreturn null\n}\n</code></pre> <p>Next we create the ResponseConverter:</p> <pre><code>if (typeData.typeInfo.type == User::class) {\nval requestType = typeData.typeArgs.first()\n\nreturn object : Converter.ResponseConverter&lt;HttpResponse, Flow&lt;Any&gt;&gt; {\noverride fun convert(getResponse: suspend () -&gt; HttpResponse): Flow&lt;Any&gt; {\nreturn flow {\ntry {\nval response = getResponse()\nif (requestType.typeInfo.type == HttpResponse::class) {\nemit(response)\n} else {\nval data = ktorfit.nextSuspendResponseConverter(this@FlowConverterFactory, requestType)\n?.convert(response)\nemit(data)\n}\n} catch (exception: Exception) {\nthrow exception\n}\n}\n}\n}\n}\n</code></pre> <p>Inside of convert we get the HttpResponse from getResponse(). We use nextSuspendResponseConverter to find the next converter that can  convert the response. Then we put the converted response in the Flow and return it.</p> <p>Finally, add your converter factory to the Ktorfit Builder</p> <pre><code>Ktorfit.Builder().converterFactories(FlowConverterFactory()).baseUrl(\"foo\").build()\n</code></pre>"},{"location":"converters/responseconverter/#flow","title":"Flow","text":"<p>Ktorfit has support for Kotlin Flow. You need add the FlowConverterFactory() to your Ktorfit instance.</p> <pre><code>ktorfit.converterFactories(FlowConverterFactory())\n</code></pre> <pre><code>@GET(\"comments\")\nfun getCommentsById(@Query(\"postId\") postId: String): Flow&lt;List&lt;Comment&gt;&gt;\n</code></pre> <p>Then you can drop the suspend modifier and wrap your return type with Flow&lt;&gt;</p>"},{"location":"converters/responseconverter/#call","title":"Call","text":"<pre><code>ktorfit.converterFactories(CallConverterFactory())\n</code></pre> <pre><code>@GET(\"people/{id}/\")\nfun getPersonById(@Path(\"id\") peopleId: Int): Call&lt;People&gt;\n</code></pre> <pre><code>exampleApi.getPersonById(3).onExecute(object : Callback&lt;People&gt; {\noverride fun onResponse(call: People, response: HttpResponse) {\n//Do something with Response\n}\n\noverride fun onError(exception: Exception) {\n//Do something with exception\n}\n})\n</code></pre> <p>You can use Call to receive the response in a Callback."},{"location":"converters/suspendresponseconverter/","title":"SuspendResponseConverter","text":"<p>Let`s say you have a function that requests a list of comments</p> <pre><code>@GET(\"posts/{postId}/comments\")\nsuspend fun getCommentsByPostId(@Path(\"postId\") postId: Int): List&lt;Comment&gt;\n</code></pre> <p>But now you want to directly wrap your comment list in your data holder class e.g. \u201cMyOwnResponse\u201d</p> <pre><code>sealed class MyOwnResponse&lt;T&gt; {\ndata class Success&lt;T&gt;(val data: T) : MyOwnResponse&lt;T&gt;()\nclass Error(val ex:Throwable) : MyOwnResponse&lt;Nothing&gt;()\n\ncompanion object {\nfun &lt;T&gt; success(data: T) = Success(data)\nfun error(ex: Throwable) = Error(ex)\n}\n}\n</code></pre> <p>To enable that, you have to implement a SuspendResponseConverter. This class will be used to wrap the Ktor response inside your wrapper class.</p> <pre><code>class MyOwnResponseConverterFactory : Converter.Factory{\n\noverride fun suspendResponseConverter(\ntypeData: TypeData,\nktorfit: Ktorfit\n): Converter.SuspendResponseConverter&lt;HttpResponse, *&gt;? {\nif(typeData.typeInfo.type == MyOwnResponse::class) {\n\nreturn object : Converter.SuspendResponseConverter&lt;HttpResponse, Any&gt; {\noverride suspend fun convert(response: HttpResponse): Any {\nreturn try {\nMyOwnResponse.success(response.body(typeData.typeArgs.first().typeInfo))\n} catch (ex: Throwable) {\nMyOwnResponse.error(ex)\n}\n}\n}\n}\nreturn null\n}\n}\n</code></pre> <p>You can then add the ResponseConverter to your Ktorfit object.</p> <pre><code>ktorfit.converterFactories(MyOwnResponseConverterFactory())\n</code></pre> <p>Now add MyOwnResponse to your function <pre><code>@GET(\"posts/{postId}/comments\")\nsuspend fun getCommentsByPostId(@Path(\"postId\") postId: Int): MyOwnResponse&lt;List&lt;Comment&gt;&gt;\n</code></pre></p>"},{"location":"fundamentals/scope/","title":"Scope of Ktorfit","text":"<p>The goal of Ktorfit is to provide a similar developer experience like Retrofit for Kotlin Multiplatform projects. It`s not a 100% drop-in replacement for Retrofit. It uses Ktor clients because they are available on nearly every compile target of KMP. Every feature should be implemented so that it works on all platforms that Ktor supports. Before a new functionality is added to Ktorfit, it should be checked if there is already a Ktor plugin for it which solves the same problem.</p>"}]}